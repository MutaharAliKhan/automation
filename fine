import re

def replace_arguments(file_path, headers):
    try:
        with open(file_path, 'r') as file:
            lines = file.readlines()

        # Filter out lines that start with 'expect('
        filtered_lines = [line for line in lines if not line.strip().startswith('expect(')]
        code = ''.join(filtered_lines)

        fill_pattern = re.compile(r'\.fill\(([^)]+)\)', re.DOTALL)
        click_pattern = re.compile(r"get_by_text\(([^)]+)\)", re.DOTALL)
        filter_pattern = re.compile(r'filter\(has_text="?([^",)]+)"?\)', re.DOTALL)
        header_index = 0

        def replace_fill(match):
            nonlocal header_index
            args = match.group(1).strip()
            if 'random.randint' in args and not 'str(random.randint' in args:
                return re.sub(r'random\.randint\(([^,]+), ([^)]+)\)', r'str(random.randint(\1, \2))', match.group(0))
            if 'str(' in args:
                return match.group(0)
            if header_index >= len(headers):
                return match.group(0)
            if ',' in args:
                first_arg, second_arg = args.split(',', 1)
                new_second_arg = f'str({headers[header_index]})'
                header_index += 1
                return f'.fill({first_arg.strip()}, {new_second_arg})'
            else:
                new_arg = f'str({headers[header_index]})'
                header_index += 1
                return f'.fill({new_arg})'

        def replace_click(match):
            nonlocal header_index
            args = match.group(1).strip()
            if 'str(' in args:
                return match.group(0)
            if header_index >= len(headers):
                return match.group(0)
            new_arg = f'str({headers[header_index]})'
            header_index += 1
            return f'get_by_text({new_arg})'

        def replace_filter(match):
            nonlocal header_index
            has_text_value = match.group(1).strip()
            if 'str(' in has_text_value:
                return match.group(0)
            if header_index >= len(headers):
                return match.group(0)
            new_has_text_value = f'str({headers[header_index]})'
            header_index += 1
            return f'filter(has_text={new_has_text_value})'

        updated_code = fill_pattern.sub(replace_fill, code)
        updated_code = click_pattern.sub(replace_click, updated_code)
        updated_code = filter_pattern.sub(replace_filter, updated_code)

        with open(file_path, 'w') as file: