import re

def replace_arguments(file_path, headers):
    try:
        with open(file_path, 'r') as file:
            lines = file.readlines()

        fill_pattern = re.compile(r'\.fill\(([^)]+)\)', re.DOTALL)
        click_pattern = re.compile(r"get_by_text\(([^)]+)\)", re.DOTALL)
        filter_pattern = re.compile(r'filter\(has_text="?([^",)]+)"?\)', re.DOTALL)
        header_index = 0

        def replace_fill(match):
            nonlocal header_index
            args = match.group(1).strip()
            if 'random.randint' in args and not 'str(random.randint' in args:
                return re.sub(r'random\.randint\(([^,]+), ([^)]+)\)', r'str(random.randint(\1, \2))', match.group(0))
            if 'str(' in args:
                return match.group(0)
            if header_index >= len(headers):
                return match.group(0)
            if ',' in args:
                first_arg, second_arg = args.split(',', 1)
                new_second_arg = f'str({headers[header_index]})'
                header_index += 1
                return f'.fill({first_arg.strip()}, {new_second_arg})'
            else:
                new_arg = f'str({headers[header_index]})'
                header_index += 1
                return f'.fill({new_arg})'

        def replace_click(match):
            nonlocal header_index
            args = match.group(1).strip()
            if 'str(' in args:
                return match.group(0)
            if header_index >= len(headers):
                return match.group(0)
            new_arg = f'str({headers[header_index]})'
            header_index += 1
            return f'get_by_text({new_arg})'

        def replace_filter(match):
            nonlocal header_index
            has_text_value = match.group(1).strip()
            if 'str(' in has_text_value:
                return match.group(0)
            if header_index >= len(headers):
                return match.group(0)
            new_has_text_value = f'str({headers[header_index]})'
            header_index += 1
            return f'filter(has_text={new_has_text_value})'

        updated_code_lines = []
        for line in lines:
            if 'expect(' in line and 'get_by_text' in line:
                # Skip replacing get_by_text within expect statements
                updated_code_lines.append(line)
            else:
                updated_line = fill_pattern.sub(replace_fill, line)
                updated_line = click_pattern.sub(replace_click, updated_line)
                updated_line = filter_pattern.sub(replace_filter, updated_line)
                updated_code_lines.append(updated_line)

        updated_code = ''.join(updated_code_lines)

        with open(file_path, 'w') as file:
            file.write(updated_code)
    except Exception as e:
        print(f"Error processing file {file_path}: {e}")